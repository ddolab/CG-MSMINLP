# Random demand generator 
function rdg(num_elements::Int, stage, range; seed)
    if stage == 1
        return zeros(num_elements)
    end
    rng = MersenneTwister(seed)
    return round.(rand(rng, Uniform(range[1], range[2]), num_elements); digits=2)
end

function generate_data(num_inputs::Int, num_blends::Int, num_periods::Int, br_structure::Vector{Int64}; seed)

    rng = MersenneTwister(seed)
    # Generate maximum production capacity for each input tank
    capacities = round.(rand(rng, Uniform(500, 3000), num_inputs); digits=2)

    # Generate unit transportation cost between each possible pair of input and blending tank
    transport_cost = round.(rand(rng, Uniform(0.1, 0.2), (num_inputs, num_blends)); digits=2)

    # Generate installation cost for each input tank at each period
    install_cost = zeros(num_inputs, num_periods)
    for t in 1:num_periods
        install_cost[:, t] = round.(rand(rng, Uniform(200000, 400000) * (num_periods - t + 1), num_inputs) .* capacities ./ sum(capacities); digits=2)
    end

    # Generate deterministic min/max demand at each blending tank (for testing purposes only)
    # DO NOT comment out (else state of rng will change and the rest of the data will be different) 
    max_demand = round.(rand(rng, Uniform(5000, 10000), (num_blends, num_periods)); digits=2)
    min_demand = round.(rand(rng, Uniform(100, 2000), (num_blends, num_periods)); digits=2)

    # Generate payment function for each blending tank
    payment_intercept_unsorted = round.(rand(rng, Uniform(5, 20), (num_blends, num_periods)); digits=2)
    payment_intercept = similar(payment_intercept_unsorted)

    for i in 1:size(payment_intercept_unsorted, 1)
        payment_intercept[i, :] = sort(payment_intercept_unsorted[i, :]; rev=false)
    end

    payment_slope = round.(rand(rng, Uniform(20, 50), (num_blends, num_periods)); digits=2)

    # Generate unit production cost at each input tank
    production_cost = round.(rand(rng, Uniform(10, 20), (num_inputs, num_periods)); digits=2)

    # Generate quality specification for each input tank
    quality_spec = round.(rand(rng, Uniform(0, 1), num_inputs); digits=2)

    tree = Tree(br_structure)
    stage_nodes = accumulate(*,br_structure)
    minimum_demand_nodal = Vector{Vector{Float64}}[]
    maximum_demand_nodal = Vector{Vector{Float64}}[]

    N = 0
    for (index,i) in enumerate(stage_nodes)
        push!(minimum_demand_nodal, Vector{Float64}[])
        push!(maximum_demand_nodal, Vector{Float64}[])
        for j in 1:i
            N += 1
            push!(minimum_demand_nodal[index], round.(rdg(num_blends,index,[100,2000]; seed = seed*(1+N)); digits=2))
            push!(maximum_demand_nodal[index], round.(rdg(num_blends,index,[5000,10000]; seed = seed*(1+N)); digits=2))
        end
    end
    @assert N == maximum(Blending.nodes(tree))

    minimum_demand = vcat(minimum_demand_nodal...)
    maximum_demand = vcat(maximum_demand_nodal...)

    # updating proabalities generated by the original Tree struct
    for n in Blending.nodes(tree)
        tree.probability[n] = 1/(br_structure[Blending.stage(tree, n)[1]+1])
    end

    node_total_prob = Float64[]
    for n in Blending.nodes(tree)
        push!(node_total_prob, Blending.total_node_probability(tree, n))
    end

    data = ModelDataNodalStochastic(num_inputs,
        num_blends,
        num_periods,
        node_total_prob,
        payment_slope,
        payment_intercept,
        capacities,
        install_cost,
        transport_cost,
        production_cost,
        quality_spec,
        maximum_demand,
        minimum_demand)

    return data
end

